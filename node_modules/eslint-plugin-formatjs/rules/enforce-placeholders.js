"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const icu_messageformat_parser_1 = require("@formatjs/icu-messageformat-parser");
class PlaceholderEnforcement extends Error {
    constructor(message) {
        super();
        this.message = message;
    }
}
function keyExistsInExpression(key, values) {
    if (!values) {
        return false;
    }
    if (values.type !== 'ObjectExpression') {
        return true; // True bc we cannot evaluate this
    }
    if (values.properties.find(prop => prop.type === 'SpreadElement')) {
        return true; // True bc there's a spread element
    }
    return !!values.properties.find(prop => {
        if (prop.type !== 'Property') {
            return false;
        }
        switch (prop.key.type) {
            case 'Identifier':
                return prop.key.name === key;
            case 'Literal':
                return prop.key.value === key;
        }
        return false;
    });
}
function verifyAst(ast, values, ignoreList) {
    for (const el of ast) {
        if ((0, icu_messageformat_parser_1.isLiteralElement)(el) || (0, icu_messageformat_parser_1.isPoundElement)(el)) {
            continue;
        }
        const key = el.value;
        if (!ignoreList.has(key) && !keyExistsInExpression(key, values)) {
            throw new PlaceholderEnforcement(`Missing value for placeholder "${el.value}"`);
        }
        if ((0, icu_messageformat_parser_1.isPluralElement)(el) || (0, icu_messageformat_parser_1.isSelectElement)(el)) {
            for (const selector of Object.keys(el.options)) {
                verifyAst(el.options[selector].value, values, ignoreList);
            }
        }
        if ((0, icu_messageformat_parser_1.isTagElement)(el)) {
            verifyAst(el.children, values, ignoreList);
        }
    }
}
function checkNode(context, node) {
    const settings = (0, util_1.getSettings)(context);
    const msgs = (0, util_1.extractMessages)(node, {
        excludeMessageDeclCalls: true,
        ...settings,
    });
    const { options: [opt], } = context;
    const ignoreList = new Set(opt?.ignoreList || []);
    for (const [{ message: { defaultMessage }, messageNode, }, values,] of msgs) {
        if (!defaultMessage || !messageNode) {
            continue;
        }
        try {
            verifyAst((0, icu_messageformat_parser_1.parse)(defaultMessage, {
                ignoreTag: settings.ignoreTag,
            }), values, ignoreList);
        }
        catch (e) {
            context.report({
                node: messageNode,
                message: e instanceof Error ? e.message : String(e),
            });
        }
    }
}
const rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce that all messages with placeholders have enough passed-in values',
            category: 'Errors',
            recommended: true,
            url: 'https://formatjs.io/docs/tooling/linter#enforce-placeholders',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    ignoreList: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const callExpressionVisitor = (node) => checkNode(context, node);
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                CallExpression: callExpressionVisitor,
            }, {
                CallExpression: callExpressionVisitor,
            });
        }
        return {
            JSXOpeningElement: (node) => checkNode(context, node),
            CallExpression: callExpressionVisitor,
        };
    },
};
exports.default = rule;
